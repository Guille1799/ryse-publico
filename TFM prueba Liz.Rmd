---
title: "R pruebas API RIOT"
output: html_notebook
---


```{r}
library(httr)
library(jsonlite)
library(lubridate)
library(dplyr)
library(readr)

rm(list = ls())

api_key <- "RGAPI-818655b4-16bc-45b3-9a85-c79467213da7"
routing <- "europe"
region <- "EUW1"
```


```{r}
# Sacar lista de jugadores de Master, GrandMaster y Challenger
get_master_players_puuids <- function(region, queue, api_key) {
  
  # Construir la URL
  url <- paste0("https://", region, ".api.riotgames.com/lol/league/v4/masterleagues/by-queue/",
                queue, "?api_key=", api_key)
  
  # Llamada a la API
  res <- GET(url)
  
  # Procesar respuesta
  if (status_code(res) == 200) {
    players_info <- fromJSON(content(res, "text"))
    
    # Extraer puuid
    df_players_master <- as.data.frame(players_info$entries) %>%
      select(puuid)
    
    return(df_players_master)
    Sys.sleep(10)
    
  } else {
    cat("❌ Error HTTP:", status_code(res), "\n")
    return(NULL)
  }
}


get_grandmaster_players_puuids <- function(region, queue, api_key) {
  url <- paste0("https://", region, ".api.riotgames.com/lol/league/v4/grandmasterleagues/by-queue/",
                queue, "?api_key=", api_key)
  
  res <- GET(url)
  
  if (status_code(res) == 200) {
    players_info <- fromJSON(content(res, "text"))
    df <- as.data.frame(players_info$entries) %>%
      select(puuid)
    return(df)
    Sys.sleep(5)
  } else {
    cat("❌ Error HTTP:", status_code(res), "\n")
    return(NULL)
  }
}

get_challenger_players_puuids <- function(region, queue, api_key) {
  url <- paste0("https://", region, ".api.riotgames.com/lol/league/v4/challengerleagues/by-queue/",
                queue, "?api_key=", api_key)
  
  res <- GET(url)
  
  if (status_code(res) == 200) {
    players_info <- fromJSON(content(res, "text"))
    df <- as.data.frame(players_info$entries) %>%
      select(puuid)
    return(df)
    Sys.sleep(5)
  } else {
    cat("❌ Error HTTP:", status_code(res), "\n")
    return(NULL)
  }
}

```

```{r}
queue <- "RANKED_SOLO_5x5"
# Obtener lista de jugadores Master
master_players_puuids <- get_master_players_puuids(region, queue, api_key)
```


```{r}
# Obtener lista de jugadores Grandmaster
grandmaster_players_puuids <- get_grandmaster_players_puuids(region, queue, api_key)

# Obtener lista de jugadores Challenger
challenger_players_puuids <- get_challenger_players_puuids(region, queue, api_key)

# Combinar las listas (eliminar NULLs si alguna petición falló)
all_high_elo_puuids <- bind_rows(
  if (!is.null(master_players_puuids)) master_players_puuids else data.frame(),
  if (!is.null(grandmaster_players_puuids)) grandmaster_players_puuids else data.frame(),
  if (!is.null(challenger_players_puuids)) challenger_players_puuids else data.frame()
)

# Imprimir el resultado
if (!is.null(all_high_elo_puuids) && nrow(all_high_elo_puuids) > 0) {
  cat("\n--- Lista de PUUIDs de jugadores Master, Grandmaster y Challenger ---\n")
  print(all_high_elo_puuids)
  cat("\nTotal de jugadores encontrados:", nrow(all_high_elo_puuids), "\n")
} else {
  cat("\n️ No se encontraron jugadores Master, Grandmaster o Challenger en la región y cola especificadas.\n")
}

```

```{r}

```



```{r}
# ────────────────────────────────────────────────────────────────
# 6. GUARDAR RESULTADO EN DISCO
# ────────────────────────────────────────────────────────────────
# Usa write.csv (base R) o write_csv (readr).  Ejemplo con base R:
write.csv(
  all_high_elo_puuids,
  file      = "high_elo_puuids_euw_testeo.csv",   # nombre que prefieras
  row.names = FALSE,                       # no incluir la columna de índices
  na        = ""                           # opcional: dejar vacías las celdas NA
)

cat("\n✅ Archivo 'high_elo_puuids_euw.csv' guardado en el directorio de trabajo.\n")

```

```{r}
# Cargar CSV
high_elo_puuids <- read.csv("high_elo_puuids_euw.csv", stringsAsFactors = FALSE)

# Validar y filtrar
if (!"puuid" %in% colnames(high_elo_puuids)) {
  stop("❌ El archivo no contiene una columna llamada 'puuid'.")
}

# Eliminar duplicados
high_elo_puuids <- high_elo_puuids %>% distinct(puuid, .keep_all = TRUE)

# Ver primeras filas
head(high_elo_puuids)
```

```{r}
## 1. helper  ---------------------------------------------------------------
`%||%` <- function(a,b) if (is.null(a) || length(a)==0) b else a

safe_GET <- function(url, token, pause = 1.3){
  r <- GET(url, add_headers(`X-Riot-Token` = token))
  if (status_code(r) == 429){         # rate-limit
    message("⏳ Rate-limit: espero 65 s…"); Sys.sleep(65)
    r <- GET(url, add_headers(`X-Riot-Token` = token))
  }
  if (status_code(r) != 200) stop("HTTP ", status_code(r),
                                  " – ", url, call. = FALSE)
  Sys.sleep(pause)
  r
}

## 2. función principal  ----------------------------------------------------
get_match_stats_by_puuid <- function(puuid,
                                     n        = 50,
                                     queueId  = 420,
                                     routing  = "europe",
                                     region   = "EUW1",
                                     api_key)
{
  ## Variables diana (37) ---------------------------------------------------
  wanted <- c(
    "puuid","gameName","tagLine","tier","leaguePoints",
    "match_id","gameDuration","championName","individualPosition",
    "champLevel","goldEarned","totalMinionsKilled",
    "kills","deaths","assists",
    "totalDamageDealt","totalDamageTaken",
    "damageDealtToBuildings","damageDealtToObjectives","damageDealtToTurrets",
    "visionScore","baron_kills","dragon_kills","tower_kills",
    "herald_kills","inhibitor_kills","champion_kills","win","date",
    "longestTimeSpentLiving","timeCCingOthers","timePlayed",
    "totalTimeCCDealt","totalTimeSpentDead",
    "completeSupportQuestInTime","firstTurretKilledTime","mejaisFullStackInTime"
  )
  
  ## A. lista de match-IDs --------------------------------------------------
  list_url <- sprintf(
    "https://%s.api.riotgames.com/lol/match/v5/matches/by-puuid/%s/ids?start=0&count=%d&queue=%d",
    routing, puuid, n, queueId
  )
  ids <- safe_GET(list_url, api_key, 0) |> content("text") |> fromJSON()
  if (length(ids) == 0) return(tibble())          # sin partidas
  
  ## B. rango / LP solo en Solo-Duo ----------------------------------------
  tier_url <- sprintf(
    "https://%s.api.riotgames.com/lol/league/v4/entries/by-puuid/%s?api_key=%s",
    region, puuid, api_key
  )
  tier_dat <- safe_GET(tier_url, api_key, 0.4) |> content("text") |> fromJSON()
  
  tier_row <- dplyr::filter(tier_dat, queueType == "RANKED_SOLO_5x5")
  tier         <- tier_row$tier[1]         %||% NA_character_
  leaguePoints <- tier_row$leaguePoints[1] %||% NA_integer_
  
  ## C. bajar cada partida --------------------------------------------------
  fetch_one <- function(match_id){
    m_url <- sprintf("https://%s.api.riotgames.com/lol/match/v5/matches/%s",
                     routing, match_id)
    info <- safe_GET(m_url, api_key) |> content("text") |> fromJSON()
    
    if (info$info$queueId != queueId) return(NULL)    # por si acaso
    
    me <- info$info$participants |>
          dplyr::filter(puuid == !!puuid)
    
    teamIdx <- which(info$info$teams$teamId == me$teamId)
    obj     <- info$info$teams$objectives
    
    tibble(
      puuid   = puuid,
      gameName= me$riotIdGameName %||% NA_character_,
      tagLine = me$riotIdTagline  %||% NA_character_,
      tier    = tier,
      leaguePoints = leaguePoints,
      match_id     = match_id,
      gameDuration = info$info$gameDuration,
      championName = me$championName,
      individualPosition = me$individualPosition,
      champLevel = me$champLevel,
      goldEarned = me$goldEarned,
      totalMinionsKilled = me$totalMinionsKilled,
      kills   = me$kills, deaths = me$deaths, assists = me$assists,
      totalDamageDealt = me$totalDamageDealt,
      totalDamageTaken = me$totalDamageTaken,
      damageDealtToBuildings = me$damageDealtToBuildings,
      damageDealtToObjectives = me$damageDealtToObjectives,
      damageDealtToTurrets   = me$damageDealtToTurrets,
      visionScore            = me$visionScore,
      baron_kills     = obj$baron$kills     [teamIdx] %||% NA_integer_,
      dragon_kills    = obj$dragon$kills    [teamIdx] %||% NA_integer_,
      tower_kills     = obj$tower$kills     [teamIdx] %||% NA_integer_,
      herald_kills    = obj$riftHerald$kills[teamIdx] %||% NA_integer_,
      inhibitor_kills = obj$inhibitor$kills [teamIdx] %||% NA_integer_,
      champion_kills  = obj$champion$kills  [teamIdx] %||% NA_integer_,
      win   = me$win,
      date  = as_datetime(info$info$gameStartTimestamp/1000),
      longestTimeSpentLiving = me$longestTimeSpentLiving %||% NA_integer_,
      timeCCingOthers        = me$timeCCingOthers        %||% NA_integer_,
      timePlayed             = me$timePlayed             %||% NA_integer_,
      totalTimeCCDealt       = me$totalTimeCCDealt       %||% NA_integer_,
      totalTimeSpentDead     = me$totalTimeSpentDead     %||% NA_integer_,
      completeSupportQuestInTime = me$completeSupportQuestInTime %||% NA,
      firstTurretKilledTime      = me$firstTurretKilledTime      %||% NA,
      mejaisFullStackInTime      = me$mejaisFullStackInTime      %||% NA
    )
  }
  
  out <- purrr::map(ids, fetch_one) |> purrr::compact() |> dplyr::bind_rows()
  
  ## D. asegurar columnas y tipos ------------------------------------------
  missing_cols <- setdiff(wanted, names(out))
  if (length(missing_cols) > 0){
    out[missing_cols] <- NA
  }
  out <- out |> dplyr::mutate(across(where(is.logical), as.integer)) |>
         dplyr::select(all_of(wanted))
  
  out
}

```

```{r}
# Ruta del archivo donde se va acumulando todo
output_file <- "match_stats_full.csv"

# Cargar archivo si ya existe (para evitar duplicados al reiniciar)
if (file.exists(output_file)) {
  df_all <- read_csv(output_file, show_col_types = FALSE)
  puuids_done <- unique(df_all$puuid)
} else {
  df_all <- tibble()
  puuids_done <- character(0)
}

# Recorrer todos los puuids que no se han procesado aún
for (i in seq_len(nrow(high_elo_puuids))) {
  mi_puuid <- high_elo_puuids$puuid[i]

  # Saltar si ya está en el CSV
  if (mi_puuid %in% puuids_done) {
    message(sprintf("✅ PUUID %s ya procesado. Saltando...", mi_puuid))
    next
  }

  message(sprintf("📥 Descargando datos para PUUID %s (%d/%d)...",
                  mi_puuid, i, nrow(high_elo_puuids)))

  # Intentar obtener datos
  try({
    df_puuid <- get_match_stats_by_puuid(
      puuid    = mi_puuid,
      n        = 50,
      queueId  = 420,
      routing  = routing,
      region   = region,
      api_key  = api_key
    )

    # Si no está vacío, agregar y guardar
    if (nrow(df_puuid) > 0) {
      df_all <- bind_rows(df_all, df_puuid)

      # Guardar CSV en cada iteración
      write_csv(df_all, output_file)
      message(sprintf("💾 Guardado exitoso. Total acumulado: %d partidas.",
                      nrow(df_all)))
    } else {
      message("⚠️ No se obtuvieron datos para este PUUID.")
    }

    Sys.sleep(1.5)  # evitar throttle
  }, silent = FALSE)
}

```


Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
